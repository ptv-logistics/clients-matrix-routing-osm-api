/* tslint:disable */
/* eslint-disable */
/**
 * Matrix Routing OSM
 * With the Matrix Routing OSM service you can compute distances and travel times between a set of origins and destinations based on open street map data.
 *
 * The version of the OpenAPI document: 1.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorResponse,
  Locations,
  MatrixIdentifier,
  MatrixResponse,
  Options,
  Results,
  StatusResponse,
} from '../models/index';
import {
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    LocationsFromJSON,
    LocationsToJSON,
    MatrixIdentifierFromJSON,
    MatrixIdentifierToJSON,
    MatrixResponseFromJSON,
    MatrixResponseToJSON,
    OptionsFromJSON,
    OptionsToJSON,
    ResultsFromJSON,
    ResultsToJSON,
    StatusResponseFromJSON,
    StatusResponseToJSON,
} from '../models/index';

export interface CalculateMatrixRequest {
    locations: Locations;
    profile?: string;
    results?: Array<Results>;
    options?: Options;
}

export interface CancelMatrixCalculationRequest {
    id: string;
}

export interface GetMatrixRequest {
    id: string;
}

export interface GetStatusRequest {
    id: string;
    maximumPollingPeriod?: number;
}

export interface StartMatrixCalculationRequest {
    locations: Locations;
    profile?: string;
    results?: Array<Results>;
    options?: Options;
}

/**
 * 
 */
export class MatricesApi extends runtime.BaseAPI {

    /**
     * Creates a matrix by calculating distances and travel times between given origins and destinations.
     */
    async calculateMatrixRaw(requestParameters: CalculateMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixResponse>> {
        if (requestParameters['locations'] == null) {
            throw new runtime.RequiredError(
                'locations',
                'Required parameter "locations" was null or undefined when calling calculateMatrix().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationsToJSON(requestParameters['locations']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixResponseFromJSON(jsonValue));
    }

    /**
     * Creates a matrix by calculating distances and travel times between given origins and destinations.
     */
    async calculateMatrix(requestParameters: CalculateMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixResponse> {
        const response = await this.calculateMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Cancels a matrix calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
     */
    async cancelMatrixCalculationRaw(requestParameters: CancelMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling cancelMatrixCalculation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancels a matrix calculation and deletes the calculated results specified by its ID. Results already calculated cannot be requested by its ID, anymore.
     */
    async cancelMatrixCalculation(requestParameters: CancelMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelMatrixCalculationRaw(requestParameters, initOverrides);
    }

    /**
     * Requests the results of a matrix calculation operation.
     */
    async getMatrixRaw(requestParameters: GetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getMatrix().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixResponseFromJSON(jsonValue));
    }

    /**
     * Requests the results of a matrix calculation operation.
     */
    async getMatrix(requestParameters: GetMatrixRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixResponse> {
        const response = await this.getMatrixRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Requests the status of a matrix calculation.
     */
    async getStatusRaw(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StatusResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getStatus().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['maximumPollingPeriod'] != null) {
            queryParameters['maximumPollingPeriod'] = requestParameters['maximumPollingPeriod'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/status/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StatusResponseFromJSON(jsonValue));
    }

    /**
     * Requests the status of a matrix calculation.
     */
    async getStatus(requestParameters: GetStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StatusResponse> {
        const response = await this.getStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a matrix asynchronously by calculating distances and travel times between given origins and destinations.
     */
    async startMatrixCalculationRaw(requestParameters: StartMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatrixIdentifier>> {
        if (requestParameters['locations'] == null) {
            throw new runtime.RequiredError(
                'locations',
                'Required parameter "locations" was null or undefined when calling startMatrixCalculation().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['profile'] != null) {
            queryParameters['profile'] = requestParameters['profile'];
        }

        if (requestParameters['results'] != null) {
            queryParameters['results'] = requestParameters['results']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['options'] != null) {
            queryParameters['options'] = requestParameters['options'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["apiKey"] = await this.configuration.apiKey("apiKey"); // apiKeyAuth authentication
        }

        const response = await this.request({
            path: `/matrices/async`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationsToJSON(requestParameters['locations']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatrixIdentifierFromJSON(jsonValue));
    }

    /**
     * Creates a matrix asynchronously by calculating distances and travel times between given origins and destinations.
     */
    async startMatrixCalculation(requestParameters: StartMatrixCalculationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatrixIdentifier> {
        const response = await this.startMatrixCalculationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
